---
date: '2020-01-03'
title: "Gatsby vs Next.js : le Mayweather vs McGregor du d√©veloppement front-end"
featuredImage: '../images/2020-01-03-gatsby-vsnextjs/fight.png'
lang: fr
---

<Image align="right">

![](../images/2020-01-03-gatsby-vsnextjs/fight.png)

</Image>

L'ann√©e derni√®re, il m'a √©t√© donn√©e l'opportunit√© de travailler √† la fois avec [Gatsby](https://www.gatsbyjs.org/) et avec [Next.js](https://nextjs.org/). Tous deux bas√©es sur ReactJS, ces framework cr√©ent une architecture normalis√©e et permettent d'acc√©l√©rer la cr√©ation de sites web, ainsi que de leur donner des super-pouvoirs pour am√©liorer l'accessibilit√©, le SEO et les performances.

La popularit√© de ces deux frameworks est similaire √† l'heure actuelle, Gatsby et Next.js ont respectivement 41.9k et 43k stars sur Github.

## ü§ù Les points communs

Avant de regarder ce qui oppose ces deux solutions, regardons ensemble leurs similarit√©s qui existent entre Next.js et Gatsby.

<Image isSmall>

![](https://media.giphy.com/media/CHmwA02GQ6aTS/giphy.gif)

</Image>

### Courbe d'apprentissage

Pour un‚Ä¢e d√©velopeur‚Ä¢euse familier‚Ä¢√®re avec React, la prise en main tant de Next.js ou Gatsby ne sera pas difficile. La documentation de ces deux frameworks est tr√®s bien faite et les vid√©os ou articles sur le sujet sont l√©gion.

Gr√¢ce √† des plateforme d'h√©bergement statiques comme Netlify, Gitlab Pages, Now.sh..., il sera de plus tr√®s facile de d√©ployer le site cr√©√©. En quelques heures vous pouvez donc disposer d'un site web statique.

### Outils de build int√©gr√©s

La cr√©ation d'une app avec React seule peut vite √™tre prise de t√™te : il faut configurer Webpack, ajouter Babel pour utiliser les derni√®res fonctionnalit√©s ES7, ajouter un syst√®me de minification pour les build en production, mettre en place du live-reload pour le d√©veloppement...

Ici, toutes ces questionnements sont r√©solus d√®s le d√©part et g√©r√©s de fa√ßon transparente par les outils de build int√©gr√©s. En laissant le‚Ä¢a d√©veloppeur‚Ä¢euse se concentrer sur sa vraie valeur ajout√©e, ces framework permettent une prise en main et un d√©veloppement tr√®s rapide.

### G√©n√©ration automatiques de pages

Les architectures Next.js comme Gatsby poss√®dent un dossier `/src/pages` o√π nativement, les composants qui y sont stock√©s seront transform√©s en pages et servies par le framework.

Ainsi, le fichier `/src/pages/index.js` sera accessible √† l'adresse `/` et le fichier `/src/pages/about.js` √† l'adresse `/about`. L'arborescence sur plusieurs niveaux est aussi prise en charge de telle sorte que le fichier `/src/pages/posts/post-1.js` aura pour URL `/posts/post-1`.

### Routing int√©gr√©

Les deux frameork poss√®dent leur propre syst√®me de routing et de liens internes. Ils ont la particularit√© d'√™tre tous deux bas√©s sur [@reach/router](https://github.com/reach/router) de Ryan Florence.

Parce qu'ils g√®rent eux m√™me le routing, ils offrent nativement du link-prefetching, acc√©l√©rant ainsi l'impression de rapidit√© pour les utilisateurs finaux.

## ‚öîÔ∏è Ce qui les oppose

<Image isSmall>

![](https://media.giphy.com/media/Dea0leKapJzJC/giphy.gif)

</Image>

### Pr√©-rendering VS rendu c√¥t√© serveur

Si la diff√©rence est √† peine perceptible pour les utilisateurs finaux, elle est cependant tr√®s importante d'un point de vue de d√©veloppeur‚Ä¢euse. Les pages servies par Gatsby sont statiques car les donn√©es qui les alimentent ont √©t√© t√©l√©charg√©es au moment du build (nous reviendrons sur ce m√©canisme par la suite). Ainsi, pour toute modification de contenu, il est n√©cessaire de repasser par une phase de build du site web.

Next.js en revanche propose un rendu c√¥t√© serveur. Cela signifie que les pages sont trait√©es par un serveur NodeJS au moment de la requ√™te par le client et le HTML est envoy√© tel quel. Une surcouche JavaScript va ensuite permettre de dynamiser le contenu ainsi r√©cup√©r√©.

### Gestion des donn√©es

Lors du build, Gatsby va donc r√©cup√©rer les donn√©es depuis les diff√©rentes sources qui auront √©t√© mises √† sa disposition (base de donn√©es, API, CMS Headess, fichiers markdown...) et les exposera aux pages au moyen d'une API gateway en GraphQL

Next propose une surcharge aux composants React standards. En effet, pour chaque composant page, il est possible de d√©finir une m√©thode asynchrone `getInitialProps` pour le composant. Elle sera ex√©cut√©e avant le premier rendu afin d'alimenter le composant avec un jeu de donn√©es initiales. C'est donc dans cette m√©thode qu'il faudra effectuer les appels aux services externes.

### Routing dynamique

Depuis sa version 9, sortie √† l'√©t√© 2019, Next.js int√®gre un syst√®me de routing dynamique qui utilise l'arborescence et un motif de nom de fichier. Ainsi, en nommant un fichier `pages/post/[slug].js` (le nom de fichier doit bien conserver les crochets tels quels), Next.js va automatiquement faire correspondre les URL de type `/posts/post-1` ou `/posts/1` au composant contenu dans le fichier. La valeur du slug sera alors accessible au sein du premier param√®tre de la m√©thode `getInitialProps` et pourra √™tre utilis√©e pour dynamiser les requ√™tes aux services externes.

Quant √† Gatsby, la cr√©ation de pages √† la vol√©e reste un peu plus compliqu√©e. Le fichier gatsby-node.js permet de surcharger les m√©thodes de build standard afin de cr√©er des nouveaux noeuds GraphQL ou des pages. Parce que la documentation √† ce sujet reste tr√®s bien con√ßue, cette op√©ration ne comporte pas de difficult√© majeure.

## Quand les utiliser ?

Si le contenu de votre app n'a pas besoin d'√™tre mise √† jour r√©guli√®rement (ex: blog, site institutionnel), il est conseill√© d'utiliser Gatsby, puisque les requ√™tes seront effectu√©e au moment du build et non au requ√™tage par le visiteur, et d'utiliser Next.js si l'app repose sur des input utilisateurs dynamiques (ex: newsfeed).

En revanche, comme votre app Gatsby reste bas√©e sur une app React, il sera tout de m√™me possible de brancher des API asynchrones, une architecture Redux, un client Apollo... afin d'appeler des services tiers lors du rendu c√¥t√© client.
